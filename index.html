<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- Telegram Web App Optimization -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Cop Chase">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1a1a2e">
    <meta name="msapplication-navbutton-color" content="#1a1a2e">
    
    <!-- iOS Safe Area Support -->
    <meta name="apple-touch-fullscreen" content="yes">
    <meta name="format-detection" content="telephone=no">
    
    <title>Cop Chase Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* Touch optimization for mobile */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 25%, #0f3460 50%, #533483 75%, #e94560 100%);
            color: white;
            height: 100vh;
            height: -webkit-fill-available;
            overflow: hidden;
            margin: 0;
            padding: 0;
            /* iOS Safe Area Support */
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        /* Removed rotation overlay - game now supports portrait mode */

        .container {
            width: 100vw;
            height: 100vh;
            height: -webkit-fill-available;
            margin: 0;
            padding: 0;
            overflow: hidden;
            /* Adjust for safe areas */
            min-height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
        }

        /* Menu Styles */
        .menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 40px 30px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.05) 100%);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 24px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            min-width: 320px;
            max-width: 90vw;
            min-height: 400px;
        }

        .menu h1 {
            font-size: 1.8em;
            margin-bottom: 20px;
            color: #ffd700;
            font-weight: 700;
        }

        .menu p {
            font-size: 1em;
            margin-bottom: 25px;
            opacity: 0.9;
            line-height: 1.4;
        }

        .btn {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 100%);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 18px 36px;
            font-size: 1.4em;
            font-weight: 500;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            /* Mobile touch optimization */
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0.1);
            touch-action: manipulation;
        }

        .btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        /* Game UI */
        .game-ui {
            display: none;
            flex-direction: column;
            height: 100vh;
            height: -webkit-fill-available;
            overflow: hidden;
            /* Safe area adjustments */
            padding-top: env(safe-area-inset-top);
        }

        .top-panel {
            background: rgba(0,0,0,0.15);
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: nowrap;
            position: relative;
            height: 60px;
        }

        .top-panel-left {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        /* Status integrated into top panel */

        .menu-btn {
            padding: 6px 12px;
            font-size: 12px;
            min-width: auto;
            border-radius: 8px;
            line-height: 1;
            height: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .stat {
            background: rgba(255,255,255,0.1);
            padding: 8px 16px;
            border-radius: 15px;
            font-size: 14px;
        }

        .controls {
            display: flex;
            gap: 2px;
            flex-wrap: wrap;
        }

        .dice-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 2000;
            display: none;
        }

        .dice {
            width: 50px;
            height: 50px;
            background: white;
            color: #333;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            margin: 0 auto 10px;
            border: 2px solid #333;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .dice-roll-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 160px;
            height: 160px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #f39c12 100%);
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1000;
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.4), inset 0 2px 0 rgba(255,255,255,0.3);
            font-size: 2.2em;
            font-weight: bold;
            color: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            line-height: 1.2;
        }

        .dice-roll-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 12px 35px rgba(255, 215, 0, 0.5), inset 0 2px 0 rgba(255,255,255,0.4);
            background: linear-gradient(135deg, #ffed4e 0%, #f39c12 50%, #e67e22 100%);
        }

        .dice-roll-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .dice.rolling {
            animation: roll 1s ease-in-out;
        }


        
        .dice.rolling {
            animation: roll 1s ease-in-out;
        }

        @keyframes roll {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(90deg); }
            50% { transform: rotate(180deg); }
            75% { transform: rotate(270deg); }
        }

        /* Game Board */
        .game-board {
            flex: 1;
            padding: 2px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: calc(100vh - 60px);
            padding-top: 0;
        }

        .city-grid {
            display: grid;
            gap: 1px;
            background: linear-gradient(135deg, #1a2f20 0%, #2a4d3a 50%, #1a2f20 100%);
            padding: 8px;
            border-radius: 12px;
            border: 3px solid #444;
            position: relative;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4), inset 0 2px 4px rgba(255,255,255,0.1);
            /* Ensure horizontal layout on mobile */
            min-width: fit-content;
        }

        .city-grid::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, #666, #888, #666);
            border-radius: 12px;
            z-index: -1;
        }

        .cell {
            border-radius: 2px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .land {
            background: linear-gradient(135deg, #2d5a3d 0%, #4a7c59 50%, #5d8f6a 100%);
            position: relative;
        }
        
        .land::before {
            display: none;
        }

        .land-brown {
            background: linear-gradient(135deg, #6b4423 0%, #8b6914 50%, #a0761a 100%);
            position: relative;
        }
        
        .land-brown::before {
            display: none;
        }

        .land-dark {
            background: linear-gradient(135deg, #1a3024 0%, #3a5d47 50%, #4a7c59 100%);
            position: relative;
        }
        
        .land-dark::before {
            display: none;
        }

        .land-desert {
            background: linear-gradient(135deg, #b8956a 0%, #c2a878 50%, #d4b896 100%);
            position: relative;
        }
        
        .land-desert::before {
            display: none;
        }

        .land-rocky {
            background: linear-gradient(135deg, #5a6b7a 0%, #708090 50%, #778899 100%);
            position: relative;
        }
        
        .land-rocky::before {
            display: none;
        }

        .land-grass {
            background: linear-gradient(135deg, #1a7a1a 0%, #228b22 50%, #32cd32 100%);
            position: relative;
        }
        
        .land-grass::before {
            display: none;
        }
        
        .lake {
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 50%, #60a5fa 100%);
            position: relative;
        }
        
        .shop {
            background: linear-gradient(135deg, #8b4513 0%, #a0522d 50%, #cd853f 100%);
            position: relative;
        }
        
        .shop::before {
            content: '';
            position: absolute;
            top: 20%;
            left: 20%;
            right: 20%;
            bottom: 20%;
            background: repeating-linear-gradient(
                90deg,
                rgba(255,255,255,0.3),
                rgba(255,255,255,0.3) 2px,
                transparent 2px,
                transparent 6px
            ),
            repeating-linear-gradient(
                0deg,
                rgba(255,255,255,0.2),
                rgba(255,255,255,0.2) 2px,
                transparent 2px,
                transparent 6px
            );
        }

        .movement-highlight {
            background: rgba(255, 255, 0, 0.7) !important;
            border: 3px solid #ffd700 !important;
            z-index: 15;
            transform: scale(1.05);
            box-shadow: 0 0 12px rgba(255, 215, 0, 0.8) !important;
        }

        .road {
            background: linear-gradient(135deg, #404040 0%, #555 50%, #666 100%);
            border: 1px solid #333;
            position: relative;
            box-shadow: inset 0 0 4px rgba(0,0,0,0.3);
        }

        .road::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 3px,
                rgba(0,0,0,0.1) 3px,
                rgba(0,0,0,0.1) 4px
            );
        }

        .road-horizontal {
            background: linear-gradient(180deg, #404040 0%, #555 50%, #666 100%);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2), inset 0 -2px 4px rgba(0,0,0,0.2);
        }

        .road-horizontal::before {
            content: '';
            position: absolute;
            top: 42%;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent 0%, #ffff99 20%, #ffff99 80%, transparent 100%);
            opacity: 0.8;
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .road-horizontal::after {
            content: '';
            position: absolute;
            top: 58%;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent 0%, #ffff99 20%, #ffff99 80%, transparent 100%);
            opacity: 0.8;
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .road-vertical {
            background: linear-gradient(90deg, #404040 0%, #555 50%, #666 100%);
            box-shadow: inset 2px 0 4px rgba(0,0,0,0.2), inset -2px 0 4px rgba(0,0,0,0.2);
        }

        .road-vertical::before {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            left: 42%;
            width: 2px;
            background: linear-gradient(180deg, transparent 0%, #ffff99 20%, #ffff99 80%, transparent 100%);
            opacity: 0.8;
            box-shadow: 1px 0 2px rgba(0,0,0,0.3);
        }

        .road-vertical::after {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            left: 58%;
            width: 2px;
            background: linear-gradient(180deg, transparent 0%, #ffff99 20%, #ffff99 80%, transparent 100%);
            opacity: 0.8;
            box-shadow: 1px 0 2px rgba(0,0,0,0.3);
        }

        .intersection {
            background: linear-gradient(45deg, #505050 0%, #666 25%, #777 50%, #666 75%, #505050 100%);
            position: relative;
            border: 2px solid #333;
            box-shadow: inset 0 0 8px rgba(0,0,0,0.4), 0 2px 4px rgba(0,0,0,0.3);
        }

        .intersection::before {
            content: '';
            position: absolute;
            top: 20%;
            left: 20%;
            right: 20%;
            bottom: 20%;
            background: repeating-linear-gradient(
                45deg,
                #ffff99,
                #ffff99 2px,
                transparent 2px,
                transparent 6px
            );
            opacity: 0.3;
        }

        .traffic-light {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 1px solid #222;
            box-shadow: 0 0 6px rgba(0,0,0,0.6), inset 0 1px 2px rgba(255,255,255,0.2);
        }

        .red-light { 
            background: radial-gradient(circle at 30% 30%, #ff6666, #ff4444, #cc0000);
            box-shadow: 0 0 8px #ff4444, 0 0 12px rgba(255,68,68,0.5);
        }
        
        .green-light { 
            background: radial-gradient(circle at 30% 30%, #66ff66, #44ff44, #00cc00);
            box-shadow: 0 0 8px #44ff44, 0 0 12px rgba(68,255,68,0.5);
        }

        .player {
            position: absolute;
            font-size: 16px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            transition: all 0.4s ease-in-out;
            gap: 0;
            line-height: 1;
        }

        .direction-arrow {
            font-size: 6px;
            margin-bottom: -1px;
            text-shadow: 0 0 2px rgba(0,0,0,0.8);
            line-height: 1;
        }

        .police {
            position: absolute;
            font-size: 14px;
            z-index: 9;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            transition: all 0.4s ease-in-out;
        }

        .police-light {
            position: absolute;
            top: -1px;
            width: 8px;
            height: 4px;
            border-radius: 2px;
            animation: policeFlash 1.2s infinite;
        }

        @keyframes policeFlash {
            0%, 50% { 
                background: #ff0000;
                box-shadow: 0 0 8px #ff0000, 0 0 12px #ff0000;
            }
            50.1%, 100% { 
                background: #0000ff;
                box-shadow: 0 0 8px #0000ff, 0 0 12px #0000ff;
            }
        }

        /* Direction Controls - centered on screen */
        .direction-controls {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 20px;
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-radius: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            z-index: 3000;
            min-width: 320px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .direction-btn {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 100%);
            margin: 1px;
            padding: 10px 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            color: white;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        /* Remove old color-coded borders for unified style */

        .direction-btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        /* Game Over */
        .game-over {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 50px 20px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.05) 100%);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 24px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            min-width: 320px;
            max-width: 90vw;
        }

        .game-over h2 {
            font-size: 2em;
            color: #ff4444;
            margin-bottom: 20px;
        }

        .game-over .btn {
            margin-top: 30px;
        }

        /* Instructions Popup */
        .instructions-popup {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .instructions-content {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.05) 100%);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 24px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        }

        .instructions-content h2 {
            color: #ffd700;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .instructions-content p {
            line-height: 1.6;
            margin-bottom: 20px;
            opacity: 0.9;
            text-align: left;
        }

        .instructions-close {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 100%);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 18px 36px;
            font-size: 1.4em;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            font-weight: 500;
        }

        .instructions-close:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25);
        }

        /* Map Editor Styles */
        .map-editor {
            display: none;
            flex-direction: column;
            height: 100vh;
            height: -webkit-fill-available;
            overflow: hidden;
            padding-top: env(safe-area-inset-top);
        }
        
        .editor-panel {
            background: rgba(0,0,0,0.15);
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            position: relative;
            min-height: 60px;
        }
        
        .editor-tools {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .tool-btn {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 100%);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }
        
        .editor-actions .menu-btn {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 8px;
        }
        
        .tool-btn:hover {
            transform: translateY(-1px);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.3) 0%, rgba(255, 255, 255, 0.2) 100%);
        }
        
        .tool-btn.active {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #333;
            font-weight: bold;
        }
        
        .editor-actions {
            display: flex;
            gap: 4px;
        }
        
        .editor-board {
            flex: 1;
            padding: 10px;
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .editor-grid {
            display: grid;
            gap: 1px;
            background: linear-gradient(135deg, #1a2f20 0%, #2a4d3a 50%, #1a2f20 100%);
            padding: 8px;
            border-radius: 12px;
            border: 3px solid #444;
            position: relative;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            cursor: crosshair;
        }
        
        .editor-cell {
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.1s ease;
        }
        
        .editor-cell:hover {
            border: 2px solid #ffd700;
            transform: scale(1.1);
            z-index: 10;
        }
        
        /* Map Selection Modal */
        .map-selection {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 3000;
            justify-content: center;
            align-items: center;
        }
        
        .map-selection-content {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.05) 100%);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 24px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            text-align: center;
        }
        
        .map-selection h2 {
            color: #ffd700;
            margin-bottom: 20px;
        }
        
        .map-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .map-item {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .map-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .map-info {
            text-align: left;
        }
        
        .map-name {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .map-size {
            font-size: 0.9em;
            opacity: 0.8;
        }
        
        .map-actions {
            display: flex;
            gap: 8px;
        }
        
        .map-action-btn {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .map-action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .map-action-btn.delete {
            background: rgba(255, 68, 68, 0.3);
            border-color: rgba(255, 68, 68, 0.5);
        }
        
        .map-action-btn.delete:hover {
            background: rgba(255, 68, 68, 0.5);
        }
        
        /* Cell Type Selection Popup */
        .cell-type-popup {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 4000;
            justify-content: center;
            align-items: center;
        }
        
        .cell-type-content {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.05) 100%);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 25px;
            max-width: 90vw;
            max-height: 80vh;
            overflow-y: auto;
            text-align: center;
        }
        
        .cell-type-content h3 {
            color: #ffd700;
            margin-bottom: 20px;
            font-size: 1.3em;
        }
        
        .cell-type-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 6px;
            margin-bottom: 15px;
        }
        
        .cell-type-option {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 100%);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 8px 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            min-height: 60px;
        }
        
        .cell-type-option:hover {
            transform: translateY(-2px) scale(1.02);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.3) 0%, rgba(255, 255, 255, 0.2) 100%);
            border-color: #ffd700;
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.3);
        }
        
        .cell-type-icon {
            font-size: 18px;
            line-height: 1;
        }
        
        .cell-type-name {
            font-size: 9px;
            font-weight: 500;
            text-align: center;
            line-height: 1.1;
        }
        
        .cell-type-close {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 100%);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 12px 24px;
            font-size: 14px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }
        
        .cell-type-close:hover {
            transform: translateY(-2px);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.3) 0%, rgba(255, 255, 255, 0.2) 100%);
        }
        @media (max-width: 480px) {
            .top-panel {
                flex-direction: row;
                gap: 3px; /* Reduced from 6px */
                padding: 4px 8px; /* Reduced padding */
                height: auto;
                min-height: 48px;
                justify-content: space-between;
                background: rgba(0,0,0,0.25);
                width: 100vw; /* Full width */
                margin: 0;
                box-sizing: border-box;
            }
            
            .top-panel-left {
                gap: 2px; /* Reduced from 4px */
                flex-wrap: wrap;
                /* Background removed for mobile */
                border-radius: 12px;
                padding: 3px 6px;
            }
            
            .stat {
                padding: 3px 6px;
                font-size: 11px;
                border-radius: 8px;
            }
            
            .menu-btn {
                padding: 4px 8px; /* Reduced from 6px 12px */
                font-size: 10px; /* Reduced from 12px */
                min-width: auto;
                border-radius: 6px; /* Reduced from 8px */
                line-height: 1;
                height: 28px; /* Fixed height for consistency */
                display: flex;
                align-items: center;
                justify-content: center;
                text-align: center;
            }
            
            .controls {
                gap: 1px; /* Reduced from 2px */
                /* Background removed for mobile */
                border-radius: 12px;
                padding: 3px 6px;
            }
            
            .game-board {
                padding: 0;
                padding-top: 0;
                height: calc(100vh - 60px);
                padding-bottom: 0;
                align-items: center;
                justify-content: center;
                position: fixed;
                top: 30px;
                left: 0;
                right: 0;
                overflow: hidden;
                z-index: 1;
            }
            
            .city-grid {
                padding: 3px;
                margin-bottom: 10px;
                border-radius: 6px;
                border-width: 2px;
                margin: 0 auto;
            }
            
            .direction-controls {
                position: fixed;
                bottom: 10px;
                left: 10px;
                right: 10px;
                width: calc(100vw - 20px);
                max-width: none;
                padding: 10px;
                margin: 0;
                border-radius: 12px;
                display: none;
                z-index: 3000;
                background: rgba(0,0,0,0.4);
                backdrop-filter: blur(25px);
                -webkit-backdrop-filter: blur(25px);
                border: 2px solid rgba(255,255,255,0.3);
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            }
            
            .direction-btn {
                padding: 8px 4px;
                margin: 2px;
                font-size: 9px;
                border-radius: 6px;
                backdrop-filter: blur(20px);
                -webkit-backdrop-filter: blur(20px);
                display: inline-block;
                min-width: auto;
                text-align: center;
                width: calc(33.33% - 4px);
                box-sizing: border-box;
            }
            
            .direction-controls {
                text-align: center;
                display: flex;
                justify-content: space-between;
                align-items: center;
                flex-wrap: nowrap;
            }
            
            .dice-roll-btn {
                bottom: 8px;
                right: 8px;
                width: 100px;
                height: 100px;
                font-size: 1.4em;
                border-radius: 50px;
            }
            
            .dice {
                width: 60px;
                height: 60px;
                font-size: 28px;
                border-radius: 12px;
            }
            
            .btn {
                padding: 12px 20px;
                font-size: 1.1em;
                margin: 4px;
                border-radius: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                text-align: center;
            }
            
            .menu {
                padding: 30px 20px;
                min-width: 280px;
                max-width: 85vw;
            }
            
            .menu h1 {
                font-size: 1.8em;
                margin-bottom: 15px;
            }
            
            .menu p {
                font-size: 0.9em;
                margin-bottom: 20px;
            }
            
            .instructions-content {
                padding: 20px;
                max-width: 85%;
            }
            
            .instructions-content h2 {
                font-size: 1.3em;
            }
            
            .instructions-content p {
                font-size: 0.9em;
                line-height: 1.4;
            }
            
            .instructions-close {
                padding: 12px 20px;
                font-size: 1.0em;
            }
            
            .game-over {
                padding: 30px 15px;
                min-width: 280px;
                max-width: 85vw;
            }
            
            .game-over h2 {
                font-size: 1.6em;
            }
            
            /* Mobile optimizations for cell type popup - smaller buttons */
            .cell-type-content {
                padding: 15px 10px;
                max-width: 95vw;
                border-radius: 12px;
            }
            
            .cell-type-content h3 {
                font-size: 1.0em;
                margin-bottom: 12px;
            }
            
            .cell-type-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 4px;
                margin-bottom: 12px;
            }
            
            .cell-type-option {
                padding: 6px 4px;
                min-height: 50px;
                border-radius: 6px;
                gap: 3px;
            }
            
            .cell-type-icon {
                font-size: 14px;
            }
            
            .cell-type-name {
                font-size: 7px;
            }
            
            .cell-type-close {
                padding: 8px 14px;
                font-size: 11px;
                border-radius: 8px;
            }
        }
        
    </style>
</head>
<body>
    <div class="container">
        <!-- Background Music -->
        <audio id="backgroundMusic" loop preload="auto">
            <source src="CopChase_cut.mp3" type="audio/mpeg">
            Your browser does not support the audio element.
        </audio>
        
        <!-- Main Menu -->
        <div id="menu" class="menu">
            <h1>Cop Chase</h1>
            <p style="text-align: left;">Escape from the police in this dice-rolling chase game!</p>
            <div style="margin: 20px 0; line-height: 2; text-align: left;">
                <div>🎲 Roll the dice to move</div>
                <div>🚦 Stop at red lights</div>
                <div>🚔 Avoid the police</div>
            </div>
            <div style="display: flex; flex-direction: column; gap: 10px; align-items: center;">
                <button class="btn" onclick="startGame()">Start Game</button>
                <button class="btn" onclick="showMapSelection()">Select Map</button>
                <button class="btn" onclick="showMapEditor()">Map Editor</button>
                <button class="btn" onclick="showInstructions()">How to Play</button>
            </div>
        </div>

        <!-- Map Editor -->
        <div id="mapEditor" class="map-editor">
            <div class="editor-panel">
                <div class="editor-tools">
                    <button class="tool-btn active" id="currentTool" onclick="showCellTypePopup()">🎨 Select Tool</button>
                    <span style="color: #ffd700; font-size: 12px; margin-left: 10px;">Current: <span id="currentToolIcon">🔄</span> <span id="currentToolName">Vertical Road</span></span>
                </div>
                <div class="editor-actions">
                    <button class="btn menu-btn" onclick="clearEditor()">Clear</button>
                    <button class="btn menu-btn" onclick="saveMap()">Save</button>

                    <button class="btn menu-btn" onclick="returnToMenu()">Menu</button>
                </div>
            </div>
            <div class="editor-board">
                <div id="editorGrid" class="editor-grid"></div>
            </div>
        </div>

        <!-- Game Interface -->
        <div id="gameUI" class="game-ui">
            <div class="top-panel">
                <div class="top-panel-left">
                    <div class="stat">Moves: <span id="moveCount">0</span></div>
                    <div class="stat">Status: <span id="gameStatus">Running</span></div>
                </div>
                <div class="controls">
                    <button class="btn menu-btn" id="musicBtn" onclick="toggleMusic()" style="font-size: 10px;">ON</button>
                    <button class="btn menu-btn" onclick="returnToMenu()" style="font-size: 10px;">Menu</button>
                </div>
            </div>

            <div class="game-board">
                <div id="cityGrid" class="city-grid"></div>
                
                <!-- Dice container centered on game field -->
                <div class="dice-container">
                    <div id="dice" class="dice">?</div>
                </div>
            </div>

            <!-- Circular dice roll button positioned at bottom-right -->
            <button id="rollBtn" class="dice-roll-btn" onclick="rollDice()">🎲<br>Roll</button>

            <div id="directionControls" class="direction-controls">
                <button class="btn direction-btn" onclick="chooseDirection('straight')">⬆️ Straight</button>
                <button class="btn direction-btn" onclick="chooseDirection('left')">⬅️ Left</button>
                <button class="btn direction-btn" onclick="chooseDirection('right')">➡️ Right</button>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOver" class="game-over">
            <h2 id="gameResult">Game Over!</h2>
            <p id="finalScore"></p>
            <button class="btn" onclick="startGame()">Play Again</button>
            <button class="btn" onclick="returnToMenu()">Main Menu</button>
        </div>

        <!-- Map Selection Modal -->
        <div id="mapSelection" class="map-selection">
            <div class="map-selection-content">
                <h2>🗺️ Select Map</h2>
                <div id="mapList" class="map-list">
                    <div class="map-item" onclick="selectMap('default')">
                        <div class="map-info">
                            <div class="map-name">Default Map</div>
                            <div class="map-size">16x28 - Procedural</div>
                        </div>
                        <div class="map-actions">
                            <button class="map-action-btn" onclick="event.stopPropagation(); selectMap('default')">Select</button>
                        </div>
                    </div>
                </div>
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                    <button class="btn" onclick="closeMapSelection()">Close</button>
                    <button class="btn" onclick="showMapEditor()">Create New</button>
                </div>
            </div>
        </div>

        <!-- Instructions Popup -->
        <div id="instructionsPopup" class="instructions-popup">
            <div class="instructions-content">
                <h2>🎮 How to Play</h2>
                <p>
                    🎲 <strong>Roll dice</strong> to move your car<br>
                    🚗 <strong>Choose direction</strong> at intersections<br>
                    🚦 <strong>Red lights</strong> stop you (police ignore them)<br>
                    🚔 <strong>Avoid police</strong> - they chase you!<br>
                    🛣️ <strong>Stay on roads</strong> - can't drive on land<br>
                    ❌ <strong>Game over</strong> if caught or blocked<br><br>
                    🎯 <strong>Goal:</strong> Survive as long as possible!<br>
                    📱 <strong>Best played</strong> in portrait mode
                </p>
                <button class="instructions-close" onclick="closeInstructions()">Got it!</button>
            </div>
        </div>
        
        <!-- Cell Type Selection Popup -->
        <div id="cellTypePopup" class="cell-type-popup">
            <div class="cell-type-content">
                <h3>🎨 Select Cell Type</h3>
                <div class="cell-type-grid">
                    <div class="cell-type-option" onclick="selectCellType('road-vertical')">
                        <div class="cell-type-icon">🔄</div>
                        <div class="cell-type-name">Vertical Road</div>
                    </div>
                    <div class="cell-type-option" onclick="selectCellType('road-horizontal')">
                        <div class="cell-type-icon">↔️</div>
                        <div class="cell-type-name">Horizontal Road</div>
                    </div>
                    <div class="cell-type-option" onclick="selectCellType('intersection')">
                        <div class="cell-type-icon">✕</div>
                        <div class="cell-type-name">Intersection</div>
                    </div>
                    <div class="cell-type-option" onclick="selectCellType('intersection-light')">
                        <div class="cell-type-icon">🚦</div>
                        <div class="cell-type-name">Traffic Light</div>
                    </div>
                    <div class="cell-type-option" onclick="selectCellType('land')">
                        <div class="cell-type-icon">🟫</div>
                        <div class="cell-type-name">Land</div>
                    </div>
                    <div class="cell-type-option" onclick="selectCellType('land-grass')">
                        <div class="cell-type-icon">🟩</div>
                        <div class="cell-type-name">Grass</div>
                    </div>
                    <div class="cell-type-option" onclick="selectCellType('land-dark')">
                        <div class="cell-type-icon">🟫</div>
                        <div class="cell-type-name">Industrial</div>
                    </div>
                    <div class="cell-type-option" onclick="selectCellType('land-brown')">
                        <div class="cell-type-icon">🟤</div>
                        <div class="cell-type-name">Brown Soil</div>
                    </div>
                    <div class="cell-type-option" onclick="selectCellType('land-desert')">
                        <div class="cell-type-icon">🟨</div>
                        <div class="cell-type-name">Desert</div>
                    </div>
                    <div class="cell-type-option" onclick="selectCellType('land-rocky')">
                        <div class="cell-type-icon">⛰️</div>
                        <div class="cell-type-name">Rocky</div>
                    </div>
                    <div class="cell-type-option" onclick="selectCellType('lake')">
                        <div class="cell-type-icon">💧</div>
                        <div class="cell-type-name">Lake</div>
                    </div>
                    <div class="cell-type-option" onclick="selectCellType('shop')">
                        <div class="cell-type-icon">🏪</div>
                        <div class="cell-type-name">Shop</div>
                    </div>
                </div>
                <button class="cell-type-close" onclick="closeCellTypePopup()">Close</button>
            </div>
        </div>
    </div>

    <script>
        class CityChaseGame {
            constructor(customMapData = null) {
                // Portrait mode optimized: 16 width x 28 height for optimal mobile viewing
                this.gridSize = { width: 16, height: 28 };
                
                // Calculate cell size based on available screen space optimized for mobile
                const availableWidth = Math.min(window.innerWidth - 20, 420); // Reduced for mobile
                const availableHeight = window.innerHeight - 140; // Reduced UI reserve
                
                // Calculate cell size to fit the grid with smaller cells for mobile
                const cellSizeByWidth = Math.floor(availableWidth / this.gridSize.width);
                const cellSizeByHeight = Math.floor(availableHeight / this.gridSize.height);
                this.cellSize = Math.max(Math.min(cellSizeByWidth, cellSizeByHeight, 28), 18); // Min 18px, max 28px per cell
                
                this.playerPos = { x: Math.floor(this.gridSize.width / 2), y: Math.floor(this.gridSize.height / 2) };
                this.policePos = [];
                this.moveCount = 0;
                this.gameActive = false;
                this.waitingForDirection = false;
                this.currentDiceRoll = 0;
                this.movesLeft = 0;
                this.playerDirection = 0; // 0=up, 1=right, 2=down, 3=left - start moving forward
                this.customMapData = customMapData;
                
                this.initializeGame();
            }

            initializeGame() {
                // Check if we have custom map data
                if (this.customMapData) {
                    console.log('Loading custom map:', this.customMapData.name);
                    this.loadCustomMap(this.customMapData);
                } else {
                    console.log('Creating default procedural map');
                    this.createCityGrid();
                    
                    // Use setTimeout to ensure DOM is ready for default maps too
                    setTimeout(() => {
                        // Find valid starting position for default maps
                        this.findValidPlayerStart();
                        this.spawnPolice();
                        this.updateDisplay();
                    }, 50);
                }
            }
            
            loadCustomMap(mapData) {
                console.log('Loading custom map:', mapData.name);
                
                // Load custom terrain map
                this.terrainMap = mapData.terrain;
                
                // Recreate the grid with custom terrain
                this.createCityGrid();
                
                // Use longer timeout to ensure DOM is fully rendered before placing entities
                setTimeout(() => {
                    console.log('Placing entities after DOM render...');
                    
                    // Verify DOM is ready
                    const gridCells = document.querySelectorAll('#cityGrid .cell');
                    console.log(`DOM verification: ${gridCells.length} cells found`);
                    
                    // Find a valid starting position for player
                    this.findValidPlayerStart();
                    console.log('Player positioned at:', this.playerPos);
                    
                    // Respawn police
                    this.spawnPolice();
                    console.log('Police positioned at:', this.policePos);
                    
                    // Update display to show player and police
                    this.updateDisplay();
                    
                    // Verify entities are placed
                    setTimeout(() => {
                        const playerElements = document.querySelectorAll('.player');
                        const policeElements = document.querySelectorAll('.police');
                        console.log(`Verification: ${playerElements.length} player, ${policeElements.length} police elements found`);
                        
                        if (playerElements.length === 0 || policeElements.length === 0) {
                            console.error('Entities not properly placed, attempting recovery...');
                            this.updateDisplay(); // Try again
                        }
                    }, 100);
                }, 150); // Increased delay for better reliability
            }
            
            findValidPlayerStart() {
                console.log('Finding valid player start position...');
                
                const roadPositions = [];
                
                // Collect all road positions
                for (let y = 0; y < this.gridSize.height; y++) {
                    for (let x = 0; x < this.gridSize.width; x++) {
                        if (this.isRoadOrIntersection(x, y)) {
                            roadPositions.push({ x, y });
                            console.log(`Found road at (${x}, ${y})`);
                        }
                    }
                }
                
                console.log(`Found ${roadPositions.length} total road positions`);
                
                if (roadPositions.length > 0) {
                    // Choose a random road position from the center area preferably
                    const centerX = Math.floor(this.gridSize.width / 2);
                    const centerY = Math.floor(this.gridSize.height / 2);
                    
                    // Sort by distance from center and choose from the closest ones
                    roadPositions.sort((a, b) => {
                        const distA = Math.abs(a.x - centerX) + Math.abs(a.y - centerY);
                        const distB = Math.abs(b.x - centerX) + Math.abs(b.y - centerY);
                        return distA - distB;
                    });
                    
                    // Choose from the closest quarter of positions
                    const choiceRange = Math.max(1, Math.floor(roadPositions.length / 4));
                    const randomIndex = Math.floor(Math.random() * choiceRange);
                    const chosenPos = roadPositions[randomIndex];
                    
                    this.playerPos = { x: chosenPos.x, y: chosenPos.y };
                    this.playerDirection = Math.floor(Math.random() * 4);
                    console.log(`Player positioned at (${this.playerPos.x}, ${this.playerPos.y})`);
                } else {
                    // Fallback to center if no roads found
                    console.log('No roads found, using center position');
                    this.playerPos = { 
                        x: Math.floor(this.gridSize.width / 2), 
                        y: Math.floor(this.gridSize.height / 2) 
                    };
                    this.playerDirection = 0; // Start moving forward (up)
                }
            }

            createCityGrid() {
                console.log('Creating city grid...');
                const grid = document.getElementById('cityGrid');
                grid.innerHTML = '';
                grid.style.gridTemplateColumns = `repeat(${this.gridSize.width}, ${this.cellSize}px)`;
                grid.style.gridTemplateRows = `repeat(${this.gridSize.height}, ${this.cellSize}px)`;

                // Create terrain map first (either custom or procedural)
                if (!this.terrainMap) {
                    console.log('No terrain map found, generating procedural terrain');
                    this.terrainMap = new Array(this.gridSize.height).fill(null).map(() => new Array(this.gridSize.width).fill('land'));
                    // Generate proper procedural city layout
                    this.generateVariedTerrainBlocks();
                } else {
                    console.log('Using existing terrain map');
                }

                let cellsCreated = 0;
                // Create realistic city grid with perimeter roads and internal road network
                for (let y = 0; y < this.gridSize.height; y++) {
                    for (let x = 0; x < this.gridSize.width; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.x = x;
                        cell.dataset.y = y;
                        cell.style.width = `${this.cellSize}px`;
                        cell.style.height = `${this.cellSize}px`;
                        cellsCreated++;

                        const terrainType = this.terrainMap[y][x];
                        
                        if (terrainType === 'road' || terrainType === 'road-vertical' || terrainType === 'road-horizontal' || 
                            terrainType === 'intersection' || terrainType === 'intersection-light') {
                            // Handle different road types
                            if (terrainType === 'intersection' || terrainType === 'intersection-light') {
                                // Explicit intersection from editor or generation
                                cell.classList.add('intersection');
                                
                                // Add traffic light if specified
                                if (terrainType === 'intersection-light') {
                                    const light = document.createElement('div');
                                    light.className = `traffic-light ${Math.random() > 0.5 ? 'red-light' : 'green-light'}`;
                                    cell.appendChild(light);
                                }
                            } else if (terrainType === 'road-vertical') {
                                // Explicit vertical road
                                cell.classList.add('road', 'road-vertical');
                            } else if (terrainType === 'road-horizontal') {
                                // Explicit horizontal road
                                cell.classList.add('road', 'road-horizontal');
                            } else {
                                // Generic road (fallback)
                                cell.classList.add('road');
                            }
                        } else if (this.isRoadPosition(x, y)) {
                            // Fallback for positions that should be roads based on grid pattern
                            const isPerimeter = (x === 0 || x === this.gridSize.width - 1 || y === 0 || y === this.gridSize.height - 1);
                            const isRoadX = x % 3 === 0;
                            const isRoadY = y % 5 === 0;
                            
                            if ((isRoadX && isRoadY)) {
                                // Intersection at crossing
                                cell.classList.add('intersection');
                            } else {
                                // Regular road with appropriate direction
                                cell.classList.add('road');
                                if (isRoadX || (isPerimeter && (y === 0 || y === this.gridSize.height - 1))) {
                                    cell.classList.add('road-vertical');
                                } else {
                                    cell.classList.add('road-horizontal');
                                }
                            }
                        } else {
                            // Use terrain from terrain map
                            cell.classList.add(terrainType);
                            
                            // Add appropriate content based on terrain type
                            if (terrainType === 'shop') {
                                cell.innerHTML = '🏪';
                                cell.style.fontSize = `${this.cellSize * 0.6}px`;
                            } else if (terrainType !== 'land-brown' && terrainType !== 'land-desert' && terrainType !== 'lake') {
                                // Add buildings and trees for appropriate terrain types
                                this.addTerrainFeatures(cell, terrainType);
                            }
                        }

                        grid.appendChild(cell);
                    }
                }
                console.log(`Grid created with ${cellsCreated} cells`);
            }
            
            isRoadPosition(x, y) {
                // Check if position should be a road based on grid pattern or explicit terrain
                if (this.terrainMap && this.terrainMap[y] && this.terrainMap[y][x]) {
                    const terrain = this.terrainMap[y][x];
                    if (terrain === 'road' || terrain === 'road-vertical' || terrain === 'road-horizontal' || 
                        terrain === 'intersection' || terrain === 'intersection-light') {
                        return true;
                    }
                    // If explicitly set to non-road terrain, return false
                    if (terrain !== 'land') {
                        return false;
                    }
                }
                
                // Default procedural road pattern for areas without explicit terrain
                const isPerimeter = (x === 0 || x === this.gridSize.width - 1 || y === 0 || y === this.gridSize.height - 1);
                const isRoadX = x % 3 === 0;
                const isRoadY = y % 5 === 0;
                return isPerimeter || isRoadX || isRoadY;
            }
            
            addTerrainFeatures(cell, terrainType) {
                const featureChance = Math.random();
                
                if (terrainType === 'land-dark') {
                    // Industrial areas
                    if (featureChance > 0.70) {
                        cell.innerHTML = '🏭';
                        cell.style.fontSize = `${this.cellSize * 0.55}px`;
                    } else if (featureChance > 0.60) {
                        cell.innerHTML = '🏢';
                        cell.style.fontSize = `${this.cellSize * 0.55}px`;
                    }
                } else if (terrainType === 'land-grass') {
                    // Residential areas - dramatically increased greenery for more bright green
                    if (featureChance > 0.55) { // Further increased for more houses
                        cell.innerHTML = '🏠';
                        cell.style.fontSize = `${this.cellSize * 0.5}px`;
                    } else if (featureChance > 0.25) { // Much more trees for bright green effect
                        cell.innerHTML = '🌳';
                        cell.style.fontSize = `${this.cellSize * 0.7}px`;
                    } else if (featureChance > 0.05) { // Even more evergreen trees
                        cell.innerHTML = '🌲';
                        cell.style.fontSize = `${this.cellSize * 0.7}px`;
                    }
                } else if (terrainType === 'land') {
                    // Mixed urban areas
                    if (featureChance > 0.78) {
                        cell.innerHTML = '🏢';
                        cell.style.fontSize = `${this.cellSize * 0.55}px`;
                    } else if (featureChance > 0.68) {
                        cell.innerHTML = '🏠';
                        cell.style.fontSize = `${this.cellSize * 0.5}px`;
                    } else if (featureChance > 0.60) {
                        cell.innerHTML = '🌳';
                        cell.style.fontSize = `${this.cellSize * 0.7}px`;
                    }
                } else {
                    // Other terrain types
                    if (featureChance > 0.85) {
                        cell.innerHTML = '🌳';
                        cell.style.fontSize = `${this.cellSize * 0.7}px`;
                    }
                }
            }

            generateVariedTerrainBlocks() {
                // Initialize with base land terrain
                for (let y = 0; y < this.gridSize.height; y++) {
                    for (let x = 0; x < this.gridSize.width; x++) {
                        this.terrainMap[y][x] = 'land';
                    }
                }
                
                // Create procedural road network with proper city layout
                this.generateRoadNetwork();
                
                // Generate terrain features
                this.generateTerrainFeatures();
                
                console.log('Procedural city generation complete');
            }
            
            generateRoadNetwork() {
                // Create horizontal perimeter roads at top and bottom
                for (let x = 0; x < this.gridSize.width; x++) {
                    this.terrainMap[0][x] = 'road-horizontal';
                    this.terrainMap[this.gridSize.height - 1][x] = 'road-horizontal';
                }
                
                // Create vertical perimeter roads at left and right
                for (let y = 1; y < this.gridSize.height - 1; y++) {
                    this.terrainMap[y][0] = 'road-vertical';
                    this.terrainMap[y][this.gridSize.width - 1] = 'road-vertical';
                }
                
                // Create main vertical roads (every 3 cells)
                for (let x = 3; x < this.gridSize.width - 1; x += 3) {
                    for (let y = 1; y < this.gridSize.height - 1; y++) {
                        // Skip if this position will be a horizontal road
                        if (y % 5 !== 0) {
                            this.terrainMap[y][x] = 'road-vertical';
                        }
                    }
                }
                
                // Create main horizontal roads (every 5 cells)
                for (let y = 5; y < this.gridSize.height - 1; y += 5) {
                    for (let x = 1; x < this.gridSize.width - 1; x++) {
                        // Skip if this position will be a vertical road
                        if (x % 3 !== 0) {
                            this.terrainMap[y][x] = 'road-horizontal';
                        }
                    }
                }
                
                // Create intersections at ALL road crossings
                for (let y = 0; y < this.gridSize.height; y++) {
                    for (let x = 0; x < this.gridSize.width; x++) {
                        let needsIntersection = false;
                        
                        // Check for intersections at grid crossings
                        if (x % 3 === 0 && y % 5 === 0) {
                            needsIntersection = true;
                        }
                        
                        // Check for intersections at perimeter crossings
                        if ((x === 0 || x === this.gridSize.width - 1) && (y === 0 || y === this.gridSize.height - 1)) {
                            needsIntersection = true;
                        }
                        
                        // Check for intersections where vertical roads meet top/bottom perimeter
                        if ((y === 0 || y === this.gridSize.height - 1) && x % 3 === 0) {
                            needsIntersection = true;
                        }
                        
                        // Check for intersections where horizontal roads meet left/right perimeter
                        if ((x === 0 || x === this.gridSize.width - 1) && y % 5 === 0) {
                            needsIntersection = true;
                        }
                        
                        if (needsIntersection) {
                            this.terrainMap[y][x] = 'intersection';
                            
                            // Add traffic lights to internal intersections only (not on perimeter)
                            if (x > 0 && x < this.gridSize.width - 1 && y > 0 && y < this.gridSize.height - 1) {
                                if (Math.random() < 0.75) { // Increased to 75% chance for more traffic lights
                                    this.terrainMap[y][x] = 'intersection-light';
                                }
                            }
                        }
                    }
                }
            }
            
            generateTerrainFeatures() {
                // Generate 4-7 small lakes for more water features
                const numLakes = Math.floor(Math.random() * 4) + 4;
                for (let lake = 0; lake < numLakes; lake++) {
                    const lakeSize = Math.floor(Math.random() * 3) + 2; // 2-4 cells per lake
                    this.generateLake(lakeSize);
                }
                
                // Generate 3-6 shops scattered around the city
                const numShops = Math.floor(Math.random() * 4) + 3;
                for (let shop = 0; shop < numShops; shop++) {
                    this.generateShop();
                }
                
                // Generate terrain blocks for urban variety with much more diversity
                let totalLandCells = 0;
                const maxLandCells = 20; // Increased from 16 to allow even more diverse areas
                const maxAttempts = 50; // Increased attempts for better coverage
                
                // Much better balance of terrain types with significantly more variety
                const terrainTypes = [
                    'land-brown', 'land-brown', 'land-brown', 'land-brown', // More brown soil areas
                    'land-dark', 'land-dark', 'land-dark', 'land-dark', // More industrial areas
                    'land-desert', 'land-desert', 'land-desert', 'land-desert', // More desert areas
                    'land-rocky', 'land-rocky', 'land-rocky', 'land-rocky', // More rocky/mountain areas
                    'land-grass', 'land-grass', 'land-grass', 'land-grass', 'land-grass', 'land-grass', 'land-grass', 'land-grass' // Even more green residential areas
                ];
                
                for (let attempt = 0; attempt < maxAttempts && totalLandCells < maxLandCells; attempt++) {
                    const remainingCells = maxLandCells - totalLandCells;
                    
                    // More varied cluster sizes for better city appearance
                    let clusterSize;
                    if (remainingCells >= 15) {
                        clusterSize = Math.floor(Math.random() * 8) + 5; // 5-12 cells for larger areas
                    } else if (remainingCells >= 10) {
                        clusterSize = Math.floor(Math.random() * 6) + 4; // 4-9 cells
                    } else if (remainingCells >= 6) {
                        clusterSize = Math.floor(Math.random() * 4) + 3; // 3-6 cells
                    } else if (remainingCells >= 3) {
                        clusterSize = Math.floor(Math.random() * 3) + 2; // 2-4 cells
                    } else {
                        clusterSize = Math.floor(Math.random() * 2) + 1; // 1-2 cells
                    }
                    
                    clusterSize = Math.min(clusterSize, remainingCells, 12); // Max 12 cells per cluster
                    
                    if (clusterSize <= 0) break;
                    
                    const terrainType = terrainTypes[Math.floor(Math.random() * terrainTypes.length)];
                    
                    // Find suitable position away from roads
                    let placed = false;
                    for (let placementAttempt = 0; placementAttempt < 30 && !placed; placementAttempt++) {
                        const startX = Math.floor(Math.random() * (this.gridSize.width - 6)) + 2;
                        const startY = Math.floor(Math.random() * (this.gridSize.height - 6)) + 2;
                        
                        // Check if area is clear of roads
                        if (this.terrainMap[startY][startX] === 'land' && 
                            startX % 3 !== 0 && startY % 5 !== 0) {
                            
                            // Place cluster in a more organic formation
                            let cellsToPlace = [];
                            let cellsPlaced = 0;
                            
                            // Generate positions for cluster in a more spread-out pattern
                            for (let dy = 0; dy < 5 && cellsPlaced < clusterSize; dy++) {
                                for (let dx = 0; dx < 5 && cellsPlaced < clusterSize; dx++) {
                                    const placeX = startX + dx;
                                    const placeY = startY + dy;
                                    
                                    // Add more randomness to create more organic shapes
                                    if (Math.random() > 0.25 && // 75% chance to place each cell
                                        placeX < this.gridSize.width - 1 && placeY < this.gridSize.height - 1 &&
                                        this.terrainMap[placeY][placeX] === 'land' &&
                                        placeX % 3 !== 0 && placeY % 5 !== 0) {
                                        cellsToPlace.push({x: placeX, y: placeY});
                                        cellsPlaced++;
                                    }
                                }
                            }
                            
                            // Place the cluster if we have enough valid cells
                            if (cellsToPlace.length >= Math.min(clusterSize, 2)) {
                                cellsToPlace.slice(0, clusterSize).forEach(pos => {
                                    this.terrainMap[pos.y][pos.x] = terrainType;
                                    totalLandCells++;
                                });
                                placed = true;
                            }
                        }
                    }
                }
                
                console.log(`Enhanced terrain generation complete: ${totalLandCells}/${maxLandCells} terrain cells, ${numLakes} lakes, ${numShops} shops`);
            }
            
            generateLake(lakeSize) {
                const maxAttempts = 20;
                
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    // Choose lake position away from roads
                    const centerX = Math.floor(Math.random() * (this.gridSize.width - 6)) + 3;
                    const centerY = Math.floor(Math.random() * (this.gridSize.height - 6)) + 3;
                    
                    // Make sure lake center is not on a road
                    if (centerX % 3 !== 0 && centerY % 5 !== 0) {
                        const lakePositions = [];
                        
                        // Generate lake shape (compact cluster)
                        if (lakeSize === 2) {
                            lakePositions.push({x: centerX, y: centerY}, {x: centerX + 1, y: centerY});
                        } else if (lakeSize === 3) {
                            lakePositions.push(
                                {x: centerX, y: centerY},
                                {x: centerX + 1, y: centerY},
                                {x: centerX, y: centerY + 1}
                            );
                        } else { // 4 cells
                            lakePositions.push(
                                {x: centerX, y: centerY},
                                {x: centerX + 1, y: centerY},
                                {x: centerX, y: centerY + 1},
                                {x: centerX + 1, y: centerY + 1}
                            );
                        }
                        
                        // Check if all positions are valid
                        const validLake = lakePositions.every(pos => 
                            pos.x > 0 && pos.y > 0 && 
                            pos.x < this.gridSize.width - 1 && pos.y < this.gridSize.height - 1 &&
                            pos.x % 3 !== 0 && pos.y % 5 !== 0
                        );
                        
                        if (validLake) {
                            // Place the lake
                            lakePositions.forEach(pos => {
                                this.terrainMap[pos.y][pos.x] = 'lake';
                            });
                            return; // Lake successfully placed
                        }
                    }
                }
            }
            
            generateShop() {
                const maxAttempts = 25;
                
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    // Choose shop position away from roads but accessible
                    const shopX = Math.floor(Math.random() * (this.gridSize.width - 4)) + 2;
                    const shopY = Math.floor(Math.random() * (this.gridSize.height - 4)) + 2;
                    
                    // Make sure shop is not on a road but adjacent to one for accessibility
                    if (shopX % 3 !== 0 && shopY % 5 !== 0 && this.terrainMap[shopY][shopX] === 'land') {
                        // Check if adjacent to a road for accessibility
                        const adjacentToRoad = [
                            {x: shopX - 1, y: shopY}, {x: shopX + 1, y: shopY},
                            {x: shopX, y: shopY - 1}, {x: shopX, y: shopY + 1}
                        ].some(pos => {
                            if (pos.x >= 0 && pos.x < this.gridSize.width && 
                                pos.y >= 0 && pos.y < this.gridSize.height) {
                                return pos.x % 3 === 0 || pos.y % 5 === 0; // Road position
                            }
                            return false;
                        });
                        
                        if (adjacentToRoad) {
                            this.terrainMap[shopY][shopX] = 'shop';
                            return; // Shop successfully placed
                        }
                    }
                }
            }

            spawnPolice() {
                console.log('Spawning police...');
                this.policePos = [];
                
                // Find all possible road positions for police spawning
                const roadPositions = [];
                for (let y = 0; y < this.gridSize.height; y++) {
                    for (let x = 0; x < this.gridSize.width; x++) {
                        if (this.isRoadOrIntersection(x, y)) {
                            // Don't spawn police too close to player
                            const distance = Math.abs(x - this.playerPos.x) + Math.abs(y - this.playerPos.y);
                            if (distance > 3) { // Minimum distance from player
                                roadPositions.push({ x, y });
                            }
                        }
                    }
                }
                
                console.log(`Found ${roadPositions.length} possible police positions`);
                
                // Spawn 2 police cars at different corners/areas of the map
                const numPolice = Math.min(2, roadPositions.length);
                const spawnedPositions = [];
                
                for (let i = 0; i < numPolice; i++) {
                    if (roadPositions.length > 0) {
                        let position = null;
                        let attempts = 0;
                        
                        // Try to find a position far from other police
                        while (attempts < 20 && position === null) {
                            const randomIndex = Math.floor(Math.random() * roadPositions.length);
                            const candidate = roadPositions[randomIndex];
                            
                            // Check distance from already spawned police
                            let farEnough = true;
                            for (let existingPos of spawnedPositions) {
                                const policeDistance = Math.abs(candidate.x - existingPos.x) + Math.abs(candidate.y - existingPos.y);
                                if (policeDistance < 8) { // Minimum distance between police
                                    farEnough = false;
                                    break;
                                }
                            }
                            
                            if (farEnough || attempts > 15) { // Accept position if far enough or after many attempts
                                position = candidate;
                                roadPositions.splice(randomIndex, 1);
                            }
                            attempts++;
                        }
                        
                        if (position) {
                            this.policePos.push({ ...position });
                            spawnedPositions.push({ ...position });
                            console.log(`Police ${i + 1} spawned at (${position.x}, ${position.y})`);
                        }
                    }
                }
                
                // Enhanced fallback system
                if (this.policePos.length === 0) {
                    console.log('No suitable positions found, using enhanced fallback');
                    
                    // Try all road positions with reduced distance
                    for (let y = 0; y < this.gridSize.height; y++) {
                        for (let x = 0; x < this.gridSize.width; x++) {
                            if (this.isRoadOrIntersection(x, y)) {
                                const distance = Math.abs(x - this.playerPos.x) + Math.abs(y - this.playerPos.y);
                                if (distance > 1 && this.policePos.length < 2) { // Any road not adjacent to player
                                    this.policePos.push({ x, y });
                                    console.log(`Fallback police ${this.policePos.length} at (${x}, ${y})`);
                                }
                            }
                        }
                    }
                    
                    // Final fallback: use corners if still no police
                    if (this.policePos.length === 0) {
                        const corners = [
                            { x: 0, y: 0 },
                            { x: this.gridSize.width - 1, y: 0 },
                            { x: 0, y: this.gridSize.height - 1 },
                            { x: this.gridSize.width - 1, y: this.gridSize.height - 1 }
                        ];
                        
                        for (let i = 0; i < Math.min(2, corners.length); i++) {
                            this.policePos.push({ ...corners[i] });
                            console.log(`Corner fallback police ${i + 1} at (${corners[i].x}, ${corners[i].y})`);
                        }
                    }
                }
                
                console.log(`Total police spawned: ${this.policePos.length}`);
            }

            updateDisplay() {
                console.log('Updating display...');
                console.log('Player position:', this.playerPos);
                console.log('Police positions:', this.policePos);
                
                // Clear previous positions first
                const existingEntities = document.querySelectorAll('.player, .police');
                console.log(`Removing ${existingEntities.length} existing entities`);
                existingEntities.forEach(el => {
                    el.remove();
                });

                // Update player position with direction arrow above car
                const playerCell = document.querySelector(`#cityGrid [data-x="${this.playerPos.x}"][data-y="${this.playerPos.y}"]`);
                console.log('Player cell query result:', playerCell);
                if (playerCell) {
                    const playerIcon = document.createElement('div');
                    playerIcon.className = 'player';
                    
                    const directionArrows = ['⬆️', '➡️', '⬇️', '⬅️'];
                    
                    // Arrow above, car below
                    playerIcon.innerHTML = `
                        <div class="direction-arrow">${directionArrows[this.playerDirection]}</div>
                        <div>🚗</div>
                    `;
                    
                    playerCell.appendChild(playerIcon);
                    console.log('Player icon added to cell at:', this.playerPos);
                } else {
                    console.error('Player cell not found at position:', this.playerPos);
                    console.log('Available cells:', document.querySelectorAll('#cityGrid [data-x][data-y]').length);
                    
                    // Try alternative query method
                    const allCells = document.querySelectorAll('#cityGrid .cell');
                    console.log(`Alternative search: ${allCells.length} total cells`);
                    
                    for (let cell of allCells) {
                        if (cell.dataset.x == this.playerPos.x && cell.dataset.y == this.playerPos.y) {
                            console.log('Found player cell via alternative method');
                            const playerIcon = document.createElement('div');
                            playerIcon.className = 'player';
                            const directionArrows = ['⬆️', '➡️', '⬇️', '⬅️'];
                            playerIcon.innerHTML = `
                                <div class="direction-arrow">${directionArrows[this.playerDirection]}</div>
                                <div>🚗</div>
                            `;
                            cell.appendChild(playerIcon);
                            console.log('Player icon added via alternative method');
                            break;
                        }
                    }
                }

                // Update police positions
                this.policePos.forEach((pos, index) => {
                    const policeCell = document.querySelector(`#cityGrid [data-x="${pos.x}"][data-y="${pos.y}"]`);
                    console.log(`Police ${index + 1} cell query result:`, policeCell, 'at position:', pos);
                    if (policeCell) {
                        const policeIcon = document.createElement('div');
                        policeIcon.className = 'police';
                        
                        policeIcon.innerHTML = `
                            <div class="police-light"></div>
                            <div>🚔</div>
                        `;
                        
                        policeCell.appendChild(policeIcon);
                        console.log(`Police ${index + 1} icon added to cell`);
                    } else {
                        console.error(`Police ${index + 1} cell not found at position:`, pos);
                        
                        // Try alternative query method for police
                        const allCells = document.querySelectorAll('#cityGrid .cell');
                        for (let cell of allCells) {
                            if (cell.dataset.x == pos.x && cell.dataset.y == pos.y) {
                                console.log(`Found police ${index + 1} cell via alternative method`);
                                const policeIcon = document.createElement('div');
                                policeIcon.className = 'police';
                                policeIcon.innerHTML = `
                                    <div class="police-light"></div>
                                    <div>🚔</div>
                                `;
                                cell.appendChild(policeIcon);
                                console.log(`Police ${index + 1} icon added via alternative method`);
                                break;
                            }
                        }
                    }
                });

                // Update UI
                document.getElementById('moveCount').textContent = this.moveCount;
                
                // Final verification
                setTimeout(() => {
                    const finalPlayerCount = document.querySelectorAll('.player').length;
                    const finalPoliceCount = document.querySelectorAll('.police').length;
                    console.log(`Final verification: ${finalPlayerCount} player, ${finalPoliceCount} police elements`);
                    
                    if (finalPlayerCount === 0 || finalPoliceCount === 0) {
                        console.warn('Some entities missing after display update');
                    }
                }, 50);
                
                console.log('Display update completed');
            }

            rollDice() {
                if (!this.gameActive || this.waitingForDirection) return;

                const dice = document.getElementById('dice');
                const diceContainer = document.querySelector('.dice-container');
                const rollBtn = document.getElementById('rollBtn');
                
                // Show dice container in center of field
                diceContainer.style.display = 'block';
                
                dice.classList.add('rolling');
                rollBtn.disabled = true;

                setTimeout(() => {
                    this.currentDiceRoll = Math.floor(Math.random() * 6) + 1;
                    dice.textContent = this.currentDiceRoll;
                    dice.classList.remove('rolling');
                    
                    // Hide dice container after showing result briefly
                    setTimeout(() => {
                        diceContainer.style.display = 'none';
                    }, 800);
                    
                    this.movesLeft = this.currentDiceRoll;
                    
                    // Police moves immediately after dice roll
                    this.movePolice();
                    
                    // Check for immediate game over after police move
                    if (this.checkImmediateGameOver()) {
                        return;
                    }
                    
                    // Check if all paths are blocked after police movement
                    if (this.checkAllPathsBlocked()) {
                        return;
                    }
                    
                    if (this.gameActive) {
                        this.movePlayer();
                    }
                    
                    // Don't re-enable roll button yet - wait for police turn to complete
                }, 1000);
            }

            movePlayer() {
                if (this.movesLeft <= 0) {
                    // Clear movement highlights with delay
                    setTimeout(() => {
                        this.clearMovementHighlights();
                        // Police moves again after player completes all moves
                        this.movePolice();
                        this.checkGameState();
                    }, 600);
                    return;
                }

                // Check if player has any valid moves available
                if (this.checkAllPathsBlocked()) {
                    return;
                }

                // Get next position based on current direction
                const nextPos = this.getNextPosition(this.playerPos, this.playerDirection);
                
                // Check if move is valid (includes police collision detection)
                if (!this.isValidMove(nextPos)) {
                    // Check if blocked specifically by police
                    const blockedByPolice = this.policePos.some(police => 
                        police.x === nextPos.x && police.y === nextPos.y
                    );
                    
                    if (blockedByPolice) {
                        // Blocked by police - show direction choice
                        setTimeout(() => {
                            document.getElementById('gameStatus').textContent = 'Blocked by police!';
                        }, 300);
                        this.showDirectionChoice();
                        return;
                    } else {
                        // Blocked by boundary or terrain - show direction choice
                        this.showDirectionChoice();
                        return;
                    }
                }
                
                // Move player
                this.playerPos = nextPos;
                this.movesLeft--;
                
                // Update display first to show player in new position
                this.updateDisplay();
                
                // Then highlight the movement cell
                setTimeout(() => {
                    this.highlightMovement(this.playerPos);
                }, 100);
                
                // Check if at intersection - ALWAYS show direction choice at intersections
                if (this.isIntersection(this.playerPos)) {
                    const light = this.getTrafficLight(this.playerPos);
                    if (light && light.classList.contains('red-light')) {
                        // Stop at red light and consume remaining moves
                        this.movesLeft = 0;
                        setTimeout(() => {
                            document.getElementById('gameStatus').textContent = 'Stopped at red light 🔴';
                        }, 300);
                    } else {
                        setTimeout(() => {
                            document.getElementById('gameStatus').textContent = 'At intersection';
                        }, 300);
                    }
                    // Always show direction choice at intersections regardless of traffic light
                    this.showDirectionChoice();
                    return;
                }
                
                if (this.movesLeft > 0) {
                    setTimeout(() => this.movePlayer(), 450);
                } else {
                    // Clear movement highlights after completing moves with delay
                    setTimeout(() => {
                        this.clearMovementHighlights();
                        // Police moves after player completes all moves
                        this.movePolice();
                        
                        // Check game state including blocked paths
                        if (this.gameActive && !this.checkAllPathsBlocked()) {
                            this.checkGameState();
                        }
                        
                        // Re-enable roll button after police turn completes
                        setTimeout(() => {
                            const rollBtn = document.getElementById('rollBtn');
                            rollBtn.disabled = false;
                        }, this.policePos.length * 150 + 300); // Wait for all police moves plus buffer
                    }, 800); // Increased delay to let highlighting show longer
                }
            }

            highlightMovement(pos) {
                console.log('Adding movement highlight at:', pos);
                const cell = document.querySelector(`[data-x="${pos.x}"][data-y="${pos.y}"]`);
                if (cell) {
                    // Remove any existing highlights first
                    cell.classList.remove('movement-highlight');
                    // Add highlighting with small delay to ensure it shows
                    setTimeout(() => {
                        cell.classList.add('movement-highlight');
                        console.log('Movement highlight added to cell:', cell);
                    }, 100);
                } else {
                    console.error('Cell not found for highlighting at:', pos);
                }
            }

            clearMovementHighlights() {
                document.querySelectorAll('.movement-highlight').forEach(cell => {
                    cell.classList.remove('movement-highlight');
                });
            }

            getNextPosition(pos, direction) {
                const directions = [
                    { x: 0, y: -1 }, // up
                    { x: 1, y: 0 },  // right
                    { x: 0, y: 1 },  // down
                    { x: -1, y: 0 }  // left
                ];
                
                const move = directions[direction];
                return {
                    x: pos.x + move.x,
                    y: pos.y + move.y
                };
            }

            isValidMove(pos) {
                // Check bounds first
                if (pos.x < 0 || pos.x >= this.gridSize.width || 
                    pos.y < 0 || pos.y >= this.gridSize.height) {
                    return false;
                }
                
                // Check if position is strictly a road, intersection, or traffic light
                if (!this.isRoadOrIntersection(pos.x, pos.y)) {
                    return false;
                }
                
                // Check if position is occupied by police - player cannot pass through police
                const blockedByPolice = this.policePos.some(police => 
                    police.x === pos.x && police.y === pos.y
                );
                
                if (blockedByPolice) {
                    return false;
                }
                
                return true;
            }

            getAvailableDirections(pos) {
                const directions = [];
                const moves = [
                    { x: 0, y: -1 }, // up
                    { x: 1, y: 0 },  // right
                    { x: 0, y: 1 },  // down
                    { x: -1, y: 0 }  // left
                ];

                moves.forEach(move => {
                    const newX = pos.x + move.x;
                    const newY = pos.y + move.y;
                    
                    // Check bounds and ensure it's a valid road position
                    if (newX >= 0 && newX < this.gridSize.width && 
                        newY >= 0 && newY < this.gridSize.height && 
                        this.isRoadOrIntersection(newX, newY)) {
                        
                        // Also check that the position isn't occupied by another police car
                        const occupiedByPolice = this.policePos.some(police => 
                            police.x === newX && police.y === newY && 
                            (police.x !== pos.x || police.y !== pos.y) // Don't count self
                        );
                        
                        if (!occupiedByPolice) {
                            directions.push({ x: newX, y: newY });
                        }
                    }
                });

                return directions;
            }

            chooseBestDirection(directions) {
                // Simple AI: move away from closest police
                let bestDir = directions[0];
                let maxDistance = -1;

                directions.forEach(dir => {
                    let minPoliceDistance = Infinity;
                    this.policePos.forEach(police => {
                        const distance = Math.abs(dir.x - police.x) + Math.abs(dir.y - police.y);
                        minPoliceDistance = Math.min(minPoliceDistance, distance);
                    });
                    
                    if (minPoliceDistance > maxDistance) {
                        maxDistance = minPoliceDistance;
                        bestDir = dir;
                    }
                });

                return bestDir;
            }

            isRoadOrIntersection(x, y) {
                // Check explicit terrain types first
                if (this.terrainMap && this.terrainMap[y] && this.terrainMap[y][x]) {
                    const terrain = this.terrainMap[y][x];
                    if (terrain === 'road' || terrain === 'road-vertical' || terrain === 'road-horizontal' || 
                        terrain === 'intersection' || terrain === 'intersection-light') {
                        return true;
                    }
                    // If terrain is explicitly set to non-road (like land, lake, etc.), return false
                    if (terrain !== 'land') {
                        return false;
                    }
                }
                
                // Fallback to procedural road pattern for land areas
                const isPerimeter = (x === 0 || x === this.gridSize.width - 1 || y === 0 || y === this.gridSize.height - 1);
                const isRoadX = x % 3 === 0;
                const isRoadY = y % 5 === 0;
                
                // Only allow procedural roads on land terrain
                if (this.terrainMap && this.terrainMap[y] && this.terrainMap[y][x] && 
                    this.terrainMap[y][x] !== 'land') {
                    return false;
                }
                
                return isPerimeter || isRoadX || isRoadY;
            }

            isIntersection(pos) {
                const { x, y } = pos;
                
                // Check if position has explicit intersection terrain
                if (this.terrainMap && this.terrainMap[y] && this.terrainMap[y][x]) {
                    const terrain = this.terrainMap[y][x];
                    if (terrain === 'intersection' || terrain === 'intersection-light') {
                        return true;
                    }
                }
                
                // Fallback to grid-based intersection detection
                return x % 3 === 0 && y % 5 === 0;
            }

            getTrafficLight(pos) {
                const cell = document.querySelector(`[data-x="${pos.x}"][data-y="${pos.y}"]`);
                return cell ? cell.querySelector('.traffic-light') : null;
            }

            showDirectionChoice() {
                // Check if all paths are blocked before showing direction choice
                if (this.checkAllPathsBlocked()) {
                    return;
                }
                
                this.waitingForDirection = true;
                document.getElementById('directionControls').style.display = 'block';
                // Hide the Roll button when direction controls appear
                document.getElementById('rollBtn').style.display = 'none';
            }

            chooseDirection(direction) {
                document.getElementById('directionControls').style.display = 'none';
                // Show the Roll button again when direction controls are hidden
                document.getElementById('rollBtn').style.display = 'block';
                this.waitingForDirection = false;
                
                // Calculate new direction
                let newDirection = this.playerDirection;
                if (direction === 'straight') {
                    // Keep current direction
                } else if (direction === 'left') {
                    newDirection = (this.playerDirection + 3) % 4; // Turn left
                } else if (direction === 'right') {
                    newDirection = (this.playerDirection + 1) % 4; // Turn right
                }
                
                // Check if the chosen direction is valid (includes police collision detection)
                const nextPos = this.getNextPosition(this.playerPos, newDirection);
                if (!this.isValidMove(nextPos)) {
                    const blockedByPolice = this.policePos.some(police => 
                        police.x === nextPos.x && police.y === nextPos.y
                    );
                    
                    if (blockedByPolice) {
                        setTimeout(() => {
                            document.getElementById('gameStatus').textContent = 'That direction is blocked by police!';
                        }, 300);
                    } else {
                        setTimeout(() => {
                            document.getElementById('gameStatus').textContent = 'That direction is blocked!';
                        }, 300);
                    }
                    this.showDirectionChoice();
                    return;
                }
                
                // Update player direction
                this.playerDirection = newDirection;

                // Reset status message
                setTimeout(() => {
                    document.getElementById('gameStatus').textContent = 'Running';
                }, 300);

                // Continue movement in new direction
                if (this.movesLeft > 0) {
                    setTimeout(() => this.movePlayer(), 450);
                } else {
                    // Clear movement highlights with delay
                    setTimeout(() => {
                        this.clearMovementHighlights();
                        // Police moves after player completes all moves
                        this.movePolice();
                        
                        // Check game state including blocked paths
                        if (this.gameActive && !this.checkAllPathsBlocked()) {
                            this.checkGameState();
                        }
                        
                        // Re-enable roll button after police turn completes
                        setTimeout(() => {
                            const rollBtn = document.getElementById('rollBtn');
                            rollBtn.disabled = false;
                        }, this.policePos.length * 150 + 300); // Wait for all police moves plus buffer
                    }, 800); // Increased delay to let highlighting show longer
                }
            }



            movePolice() {
                // Display police movement status with delay
                setTimeout(() => {
                    document.getElementById('gameStatus').textContent = 'Police Moving...';
                }, 300);
                
                // Move police with staggered delay for visual clarity
                const delayMultiplier = 150;
                
                this.policePos.forEach((police, index) => {
                    setTimeout(() => {
                        const directions = this.getAvailableDirections(police);
                        if (directions.length > 0) {
                            // Police moves towards player
                            let bestMove = directions[0];
                            let minDistance = Infinity;

                            directions.forEach(dir => {
                                const distance = Math.abs(dir.x - this.playerPos.x) + Math.abs(dir.y - this.playerPos.y);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    bestMove = dir;
                                }
                            });

                            // Get movement direction for status message
                            const moveDirection = this.getMovementDirection(police, bestMove);
                            
                            police.x = bestMove.x;
                            police.y = bestMove.y;
                            
                            // Update status with direction and delay
                            setTimeout(() => {
                                document.getElementById('gameStatus').textContent = `Police Moving ${moveDirection}...`;
                            }, 300);
                        } else {
                            // Police is blocked
                            setTimeout(() => {
                                document.getElementById('gameStatus').textContent = 'Police Blocked...';
                            }, 300);
                        }
                        
                        // Update display after each police move
                        this.updateDisplay();
                        
                        // Switch traffic lights and reset status after all police have moved
                        if (index === this.policePos.length - 1) {
                            setTimeout(() => {
                                this.switchTrafficLights();
                                
                                // Check if all paths are blocked after police movement
                                if (this.gameActive && this.checkAllPathsBlocked()) {
                                    return;
                                }
                                
                                if (this.gameActive) {
                                    setTimeout(() => {
                                        document.getElementById('gameStatus').textContent = 'Running';
                                        // Re-enable roll button after police turn completes
                                        const rollBtn = document.getElementById('rollBtn');
                                        rollBtn.disabled = false;
                                    }, 300);
                                }
                            }, delayMultiplier);
                        }
                    }, index * delayMultiplier);
                });
            }

            getMovementDirection(from, to) {
                const dx = to.x - from.x;
                const dy = to.y - from.y;
                
                if (dy < 0) return 'North';
                if (dy > 0) return 'South';
                if (dx > 0) return 'East';
                if (dx < 0) return 'West';
                return 'In Place';
            }

            switchTrafficLights() {
                // Switch all traffic lights after police movement
                document.querySelectorAll('.traffic-light').forEach(light => {
                    if (light.classList.contains('red-light')) {
                        light.classList.remove('red-light');
                        light.classList.add('green-light');
                    } else {
                        light.classList.remove('green-light');
                        light.classList.add('red-light');
                    }
                });
            }

            checkImmediateGameOver() {
                // Check if police moved onto player's position
                for (let police of this.policePos) {
                    if (police.x === this.playerPos.x && police.y === this.playerPos.y) {
                        setTimeout(() => {
                            document.getElementById('gameStatus').textContent = 'Caught by police!';
                        }, 300);
                        setTimeout(() => this.endGame(false), 600);
                        return true;
                    }
                }
                return false;
            }

            checkAllPathsBlocked() {
                // Check if all movement directions are blocked
                const allDirections = [0, 1, 2, 3]; // up, right, down, left
                const validDirections = allDirections.filter(dir => {
                    const nextPos = this.getNextPosition(this.playerPos, dir);
                    return this.isValidMove(nextPos);
                });
                
                if (validDirections.length === 0) {
                    // Check if blocked by police adjacent to player
                    const adjacentToPolice = this.policePos.some(police => {
                        const distance = Math.abs(police.x - this.playerPos.x) + Math.abs(police.y - this.playerPos.y);
                        return distance === 1; // Adjacent (distance of 1)
                    });
                    
                    if (adjacentToPolice) {
                        // All paths blocked and police is adjacent - game over
                        setTimeout(() => {
                            document.getElementById('gameStatus').textContent = 'Trapped by police!';
                        }, 300);
                        setTimeout(() => this.endGame(false), 600);
                        return true;
                    } else {
                        // All paths are blocked by terrain/boundaries
                        setTimeout(() => {
                            document.getElementById('gameStatus').textContent = 'All paths blocked!';
                        }, 300);
                        setTimeout(() => this.endGame(false), 600);
                        return true;
                    }
                }
                
                return false;
            }

            checkGameState() {
                // Check if caught by police
                for (let police of this.policePos) {
                    if (police.x === this.playerPos.x && police.y === this.playerPos.y) {
                        setTimeout(() => this.endGame(false), 300);
                        return;
                    }
                }

                // Update move count
                this.moveCount++;
                setTimeout(() => {
                    document.getElementById('gameStatus').textContent = 'Running';
                }, 300);

                // Game continues indefinitely - no win condition
            }

            endGame(won) {
                this.gameActive = false;
                
                // Stop background music
                stopMusic();
                
                document.getElementById('gameUI').style.display = 'none';
                document.getElementById('gameOver').style.display = 'block';
                
                if (won) {
                    document.getElementById('gameResult').textContent = '🎉 You Escaped!';
                    document.getElementById('gameResult').style.color = '#44ff44';
                } else {
                    document.getElementById('gameResult').textContent = '🚔 Caught!';
                    document.getElementById('gameResult').style.color = '#ff4444';
                }
                
                document.getElementById('finalScore').textContent = `You survived ${this.moveCount} moves!`;
            }
        }

        let game = null;
        let isMusicPlaying = false;
        let backgroundMusic = null;
        let mapEditor = null;
        let selectedMap = 'default';
        
        // Map Editor Class
        class MapEditor {
            constructor() {
                this.gridSize = { width: 16, height: 28 };
                this.cellSize = 24; // Fixed size for editor
                this.currentTool = 'road-vertical';
                this.editorMap = [];
                this.isDrawing = false;
                
                this.initializeEditor();
            }
            
            initializeEditor() {
                // Initialize empty map with vertical roads as default
                this.editorMap = new Array(this.gridSize.height).fill(null)
                    .map(() => new Array(this.gridSize.width).fill('road-vertical'));
                
                this.createEditorGrid();
            }
            
            createEditorGrid() {
                const grid = document.getElementById('editorGrid');
                grid.innerHTML = '';
                grid.style.gridTemplateColumns = `repeat(${this.gridSize.width}, ${this.cellSize}px)`;
                grid.style.gridTemplateRows = `repeat(${this.gridSize.height}, ${this.cellSize}px)`;
                
                for (let y = 0; y < this.gridSize.height; y++) {
                    for (let x = 0; x < this.gridSize.width; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'editor-cell';
                        cell.dataset.x = x;
                        cell.dataset.y = y;
                        cell.style.width = `${this.cellSize}px`;
                        cell.style.height = `${this.cellSize}px`;
                        
                        // Mouse events for drawing
                        cell.addEventListener('mousedown', (e) => {
                            this.isDrawing = true;
                            this.paintCell(x, y);
                            e.preventDefault();
                        });
                        
                        cell.addEventListener('mouseover', (e) => {
                            if (this.isDrawing) {
                                this.paintCell(x, y);
                            }
                        });
                        
                        cell.addEventListener('mouseup', () => {
                            this.isDrawing = false;
                        });
                        
                        // Touch events for mobile
                        cell.addEventListener('touchstart', (e) => {
                            this.isDrawing = true;
                            this.paintCell(x, y);
                            e.preventDefault();
                        });
                        
                        // Mobile tap for cell type selection
                        cell.addEventListener('click', (e) => {
                            if (window.innerWidth <= 480) {
                                // On mobile, show cell type popup on click
                                const popup = document.getElementById('cellTypePopup');
                                popup.style.display = 'flex';
                                
                                // Store the target cell for painting after type selection
                                window.targetCell = { x, y };
                                e.preventDefault();
                                e.stopPropagation();
                            }
                        });
                        
                        cell.addEventListener('touchmove', (e) => {
                            if (this.isDrawing) {
                                const touch = e.touches[0];
                                const element = document.elementFromPoint(touch.clientX, touch.clientY);
                                if (element && element.dataset.x && element.dataset.y) {
                                    this.paintCell(parseInt(element.dataset.x), parseInt(element.dataset.y));
                                }
                            }
                            e.preventDefault();
                        });
                        
                        cell.addEventListener('touchend', () => {
                            this.isDrawing = false;
                        });
                        
                        this.updateCellAppearance(cell, x, y);
                        grid.appendChild(cell);
                    }
                }
                
                // Global mouse up to stop drawing
                document.addEventListener('mouseup', () => {
                    this.isDrawing = false;
                });
            }
            
            paintCell(x, y) {
                if (x >= 0 && x < this.gridSize.width && y >= 0 && y < this.gridSize.height) {
                    this.editorMap[y][x] = this.currentTool;
                    const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                    if (cell) {
                        this.updateCellAppearance(cell, x, y);
                    }
                }
            }
            
            updateCellAppearance(cell, x, y) {
                const terrain = this.editorMap[y][x];
                
                // Remove all terrain classes and content
                cell.className = 'editor-cell';
                cell.innerHTML = '';
                
                // Add appropriate terrain class and styling
                if (terrain === 'road-vertical') {
                    // Explicit vertical road
                    cell.classList.add('road', 'road-vertical');
                } else if (terrain === 'road-horizontal') {
                    // Explicit horizontal road
                    cell.classList.add('road', 'road-horizontal');
                } else if (terrain === 'intersection') {
                    // Intersection without traffic light
                    cell.classList.add('intersection');
                } else if (terrain === 'intersection-light') {
                    // Intersection with traffic light
                    cell.classList.add('intersection');
                    const light = document.createElement('div');
                    light.className = `traffic-light ${Math.random() > 0.5 ? 'red-light' : 'green-light'}`;
                    cell.appendChild(light);
                } else {
                    // Land terrain types
                    cell.classList.add(terrain);
                    
                    // Add terrain features for non-lake terrains and shops
                    if (terrain === 'shop') {
                        cell.innerHTML = '🏪';
                        cell.style.fontSize = `${this.cellSize * 0.6}px`;
                    } else if (terrain !== 'lake' && terrain !== 'land-brown' && terrain !== 'land-desert') {
                        this.addTerrainFeatures(cell, terrain, x, y);
                    }
                }
            }
            
            addTerrainFeatures(cell, terrain, x, y) {
                const featureChance = Math.random();
                
                if (terrain === 'land-dark') {
                    // Industrial areas
                    if (featureChance > 0.70) {
                        cell.innerHTML = '🏭';
                        cell.style.fontSize = `${this.cellSize * 0.55}px`;
                    } else if (featureChance > 0.60) {
                        cell.innerHTML = '🏢';
                        cell.style.fontSize = `${this.cellSize * 0.55}px`;
                    }
                } else if (terrain === 'land-grass') {
                    // Residential areas - dramatically increased greenery for editor
                    if (featureChance > 0.55) { // Further increased for more houses
                        cell.innerHTML = '🏠';
                        cell.style.fontSize = `${this.cellSize * 0.5}px`;
                    } else if (featureChance > 0.25) { // Much more trees for bright green effect
                        cell.innerHTML = '🌳';
                        cell.style.fontSize = `${this.cellSize * 0.6}px`;
                    } else if (featureChance > 0.05) { // Even more evergreen trees
                        cell.innerHTML = '🌲';
                        cell.style.fontSize = `${this.cellSize * 0.6}px`;
                    }
                } else if (terrain === 'land') {
                    // Mixed urban areas
                    if (featureChance > 0.78) {
                        cell.innerHTML = '🏢';
                        cell.style.fontSize = `${this.cellSize * 0.55}px`;
                    } else if (featureChance > 0.68) {
                        cell.innerHTML = '🏠';
                        cell.style.fontSize = `${this.cellSize * 0.5}px`;
                    } else if (featureChance > 0.60) {
                        cell.innerHTML = '🌳';
                        cell.style.fontSize = `${this.cellSize * 0.6}px`;
                    }
                } else if (terrain === 'land-rocky') {
                    // Rocky terrain - add mountain emoji
                    if (featureChance > 0.7) {
                        cell.innerHTML = '⛰️';
                        cell.style.fontSize = `${this.cellSize * 0.6}px`;
                    } else if (featureChance > 0.85) {
                        cell.innerHTML = '🌳';
                        cell.style.fontSize = `${this.cellSize * 0.6}px`;
                    }
                }
            }
            
            clearMap() {
                for (let y = 0; y < this.gridSize.height; y++) {
                    for (let x = 0; x < this.gridSize.width; x++) {
                        this.editorMap[y][x] = 'road-vertical';
                        const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                        if (cell) {
                            this.updateCellAppearance(cell, x, y);
                        }
                    }
                }
            }
            
            saveMap() {
                const mapName = prompt('Enter map name:');
                if (mapName && mapName.trim()) {
                    const mapData = {
                        name: mapName.trim(),
                        width: this.gridSize.width,
                        height: this.gridSize.height,
                        terrain: this.editorMap,
                        created: new Date().toLocaleDateString()
                    };
                    
                    // Save to localStorage
                    const savedMaps = JSON.parse(localStorage.getItem('copChase_maps') || '{}');
                    savedMaps[mapName.trim()] = mapData;
                    localStorage.setItem('copChase_maps', JSON.stringify(savedMaps));
                    
                    alert('Map saved successfully!');
                    this.updateMapList();
                } else {
                    alert('Please enter a valid map name.');
                }
            }
            
            loadMap(mapName) {
                const savedMaps = JSON.parse(localStorage.getItem('copChase_maps') || '{}');
                if (savedMaps[mapName]) {
                    const mapData = savedMaps[mapName];
                    this.editorMap = mapData.terrain;
                    
                    // Update grid appearance
                    for (let y = 0; y < this.gridSize.height; y++) {
                        for (let x = 0; x < this.gridSize.width; x++) {
                            const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                            if (cell) {
                                this.updateCellAppearance(cell, x, y);
                            }
                        }
                    }
                    
                    return true;
                }
                return false;
            }
            
            updateMapList() {
                const mapList = document.getElementById('mapList');
                const savedMaps = JSON.parse(localStorage.getItem('copChase_maps') || '{}');
                
                // Clear existing custom maps (keep default)
                const defaultMap = mapList.children[0];
                mapList.innerHTML = '';
                mapList.appendChild(defaultMap);
                
                // Add saved maps
                Object.keys(savedMaps).forEach(mapName => {
                    const mapData = savedMaps[mapName];
                    const mapItem = document.createElement('div');
                    mapItem.className = 'map-item';
                    mapItem.onclick = () => selectMap(mapName);
                    
                    mapItem.innerHTML = `
                        <div class="map-info">
                            <div class="map-name">${mapData.name}</div>
                            <div class="map-size">${mapData.width}x${mapData.height} - Custom (${mapData.created})</div>
                        </div>
                        <div class="map-actions">
                            <button class="map-action-btn" onclick="event.stopPropagation(); selectMap('${mapName}')">Select</button>
                            <button class="map-action-btn" onclick="event.stopPropagation(); editMap('${mapName}')">Edit</button>
                            <button class="map-action-btn delete" onclick="event.stopPropagation(); deleteMap('${mapName}')">Delete</button>
                        </div>
                    `;
                    
                    mapList.appendChild(mapItem);
                });
            }
        }

        // Initialize music when page loads
        window.addEventListener('DOMContentLoaded', function() {
            backgroundMusic = document.getElementById('backgroundMusic');
            if (backgroundMusic) {
                backgroundMusic.volume = 0.3; // Set volume to 30%
            }
            isMusicPlaying = true; // Default state is on
            updateMusicButton(); // Initialize button display
        });

        function startMusic() {
            if (backgroundMusic && !isMusicPlaying) {
                backgroundMusic.play().then(() => {
                    isMusicPlaying = true;
                    updateMusicButton();
                }).catch(error => {
                    console.log('Music autoplay prevented:', error);
                    // Music will be started on first user interaction
                });
            }
        }

        function stopMusic() {
            if (backgroundMusic && isMusicPlaying) {
                backgroundMusic.pause();
                backgroundMusic.currentTime = 0;
                isMusicPlaying = false;
                updateMusicButton();
            }
        }

        function toggleMusic() {
            if (backgroundMusic) {
                if (isMusicPlaying) {
                    backgroundMusic.pause();
                    isMusicPlaying = false;
                } else {
                    backgroundMusic.play().then(() => {
                        isMusicPlaying = true;
                    }).catch(error => {
                        console.log('Music play failed:', error);
                        isMusicPlaying = false;
                    });
                }
                updateMusicButton();
            }
        }

        function updateMusicButton() {
            const musicBtn = document.getElementById('musicBtn');
            if (musicBtn) {
                musicBtn.textContent = isMusicPlaying ? 'ON' : 'OFF';
                musicBtn.title = isMusicPlaying ? 'Turn Off Music' : 'Turn On Music';
            }
        }

        function startGame() {
            console.log('Starting game with selected map:', selectedMap);
            
            // Clear any existing game state
            if (game) {
                game.gameActive = false;
                game = null;
            }
            
            // Hide menu and other screens
            document.getElementById('menu').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('mapEditor').style.display = 'none';
            document.getElementById('mapSelection').style.display = 'none';
            document.getElementById('directionControls').style.display = 'none';
            document.getElementById('cellTypePopup').style.display = 'none';
            document.querySelector('.dice-container').style.display = 'none';
            document.getElementById('gameUI').style.display = 'flex';
            
            // Ensure Roll button is visible
            document.getElementById('rollBtn').style.display = 'block';
            
            // Start background music
            startMusic();
            
            // Get custom map data if selected
            let customMapData = null;
            if (selectedMap !== 'default') {
                const savedMaps = JSON.parse(localStorage.getItem('copChase_maps') || '{}');
                if (savedMaps[selectedMap]) {
                    customMapData = savedMaps[selectedMap];
                    console.log('Custom map data loaded:', customMapData);
                } else {
                    console.error('Selected map not found:', selectedMap);
                    alert('Selected map not found, using default map instead.');
                    selectedMap = 'default';
                }
            }
            
            // Enhanced delay for complex custom maps
            const delay = customMapData ? 100 : 50;
            setTimeout(() => {
                console.log('Creating game instance...');
                // Create new game instance with custom map data
                game = new CityChaseGame(customMapData);
                game.gameActive = true;
                console.log('Game instance created and activated');
                
                // Additional verification for custom maps
                if (customMapData) {
                    setTimeout(() => {
                        console.log('Verifying custom map entities...');
                        const playerElements = document.querySelectorAll('.player');
                        const policeElements = document.querySelectorAll('.police');
                        
                        if (playerElements.length === 0 || policeElements.length === 0) {
                            console.warn('Entities not found, forcing display update...');
                            game.updateDisplay();
                        }
                    }, 200);
                }
            }, delay);
        }
        
        function showMapEditor() {
            document.getElementById('menu').style.display = 'none';
            document.getElementById('mapSelection').style.display = 'none';
            document.getElementById('mapEditor').style.display = 'flex';
            
            if (!mapEditor) {
                mapEditor = new MapEditor();
            }
            mapEditor.updateMapList();
            
            // Initialize tool display
            document.getElementById('currentToolName').textContent = 'Vertical Road';
            document.getElementById('currentToolIcon').textContent = '🔄';
        }
        
        function showMapSelection() {
            document.getElementById('mapSelection').style.display = 'flex';
            if (mapEditor) {
                mapEditor.updateMapList();
            }
        }
        
        function closeMapSelection() {
            document.getElementById('mapSelection').style.display = 'none';
        }
        
        function selectMap(mapName) {
            selectedMap = mapName;
            closeMapSelection();
            console.log(`Map selected: ${mapName}`);
            
            // Force update map list to ensure proper state
            if (mapEditor) {
                mapEditor.updateMapList();
            }
            
            alert(`Selected map: ${mapName === 'default' ? 'Default Map' : mapName}`);
        }
        
        function editMap(mapName) {
            showMapEditor();
            if (mapEditor && mapEditor.loadMap(mapName)) {
                alert(`Loaded map: ${mapName}`);
            }
        }
        
        function deleteMap(mapName) {
            if (confirm(`Are you sure you want to delete map "${mapName}"?`)) {
                const savedMaps = JSON.parse(localStorage.getItem('copChase_maps') || '{}');
                delete savedMaps[mapName];
                localStorage.setItem('copChase_maps', JSON.stringify(savedMaps));
                
                if (mapEditor) {
                    mapEditor.updateMapList();
                }
                
                // Reset to default if deleted map was selected
                if (selectedMap === mapName) {
                    selectedMap = 'default';
                }
                
                alert('Map deleted successfully!');
            }
        }
        

        
        function clearEditor() {
            if (mapEditor && confirm('Are you sure you want to clear the map?')) {
                mapEditor.clearMap();
            }
        }
        
        function saveMap() {
            if (mapEditor) {
                mapEditor.saveMap();
            }
        }
        


        function returnToMenu() {
            // Clear any active timers and reset game state
            if (game) {
                game.gameActive = false;
                game = null;
            }
            
            // Stop background music
            stopMusic();
            
            // Close any open popups
            document.getElementById('directionControls').style.display = 'none';
            document.getElementById('mapSelection').style.display = 'none';
            document.getElementById('cellTypePopup').style.display = 'none';
            
            // Show menu, hide other screens
            document.getElementById('gameUI').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('mapEditor').style.display = 'none';
            document.getElementById('menu').style.display = 'block';
        }

        function rollDice() {
            if (game) {
                game.rollDice();
            }
        }

        function chooseDirection(direction) {
            if (game) {
                game.chooseDirection(direction);
            }
        }


        
        function showCellTypePopup() {
            document.getElementById('cellTypePopup').style.display = 'flex';
        }
        
        function closeCellTypePopup() {
            document.getElementById('cellTypePopup').style.display = 'none';
        }
        
        function selectCellType(cellType) {
            if (mapEditor) {
                mapEditor.currentTool = cellType;
                
                // Update current tool display with both icon and name
                const toolData = {
                    'road-vertical': { name: 'Vertical Road', icon: '🔄' },
                    'road-horizontal': { name: 'Horizontal Road', icon: '↔️' },
                    'intersection': { name: 'Intersection', icon: '✕' },
                    'intersection-light': { name: 'Traffic Light', icon: '🚦' },
                    'land': { name: 'Land', icon: '🟫' },
                    'land-grass': { name: 'Grass', icon: '🟩' },
                    'land-dark': { name: 'Industrial', icon: '🟫' },
                    'land-brown': { name: 'Brown Soil', icon: '🟤' },
                    'land-desert': { name: 'Desert', icon: '🟨' },
                    'land-rocky': { name: 'Rocky', icon: '⛰️' },
                    'lake': { name: 'Lake', icon: '💧' },
                    'shop': { name: 'Shop', icon: '🏪' }
                };
                
                const tool = toolData[cellType] || { name: cellType, icon: '❓' };
                document.getElementById('currentToolName').textContent = tool.name;
                document.getElementById('currentToolIcon').textContent = tool.icon;
                
                // If we have a target cell from mobile selection, paint it
                if (window.targetCell && window.innerWidth <= 480) {
                    mapEditor.paintCell(window.targetCell.x, window.targetCell.y);
                    window.targetCell = null;
                }
                
                closeCellTypePopup();
            }
        }

        function showInstructions() {
            document.getElementById('instructionsPopup').style.display = 'flex';
        }

        function closeInstructions() {
            document.getElementById('instructionsPopup').style.display = 'none';
        }
        


    </script>
</body>

</html>